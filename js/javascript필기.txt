var : 변수가 사용되는 범위가 전역, 또는 함수 내부 로컬로 존재한다.

let : 변수가 사용되는 범위가 전역, 함수 내부로컬 외에 블록, 구분에 정의해 사용할 수 있다.
const age =28;
age = 29;

let age1 = 28;
age1 = 29; 

var age2 =29;
age2 = 30;

let lastLoggedIn =''; 
let last_logged_in = '';


# 자료형
object : 객체(여러 속성의 모음을 저장하는 공간)
string : 문자형
number : 숫자
boolean: 불리언(true=1, false=0)
null : 널
undefined : 정의되지 않음
symbol: 심볼(고유하고 변경할 수 없는 값_es6에서 추가됨)


/*
여러줄 주석처리
*/

// 해당 한줄 주석처리  


let userName = 'jisu';// string
let age =28;//number
let married = false;//boolean



const car = {
  wheels:4,
  color:'red',
  drive:function(){
    console.log("wroom wroom");
  }
};

console.log(car.color); //red
console.log(Object.keys(car)[0]);//wheels
// Object로 접근해서 keys는 [0]번째 속성이름
console.log(typeof Object.keys(car)[0]);
car.drive();
// "red"
// "wheels"
// "string"
// "wroom wroom"


# 빈 객체 생성하기
const car = new Object();	// 생성자 
const car = {};	// 리터럴 

const car ={};
car.color = 'black';

console.log(car);


--------------------------
const car ={
      wheels:4,
      color:"red"
};

console.log(car.wheels);
console.log(car['wheels']);

------------------------------
const car ={
      wheels:4,
      color:"red",
      "goes fast":true
};

// console.log(car.goes fast); // error 여러 단어로 된 속성을 접근하려면 대괄호표기법으로만 접근이 가능하다
console.log(car['goes fast']);
-----------------------------------------------
const car={
  ferrari:"california",
  porsche:"911",
  bugatti:"veyron"
};

const select="ferrari";

console.log(car[select]);
// 변수에 저장된 키를 통해서 객체의 속성에 접근하려면 
//대괄호 표기법을 사용한다
// console.log(car['select']); 
대괄호 표기법:[0]=> index즉, 위치
	      :여러 단어로 된 속성을 접근하려면 대괄호표기법으로만 접근이 가능
	      :변수에 저장된 키를 통해서 객체의 속성에 접근할때
위 

//error 문자열이 아닌 변수 이름에 따옴표가 들어가면 안됨.
//console.log(car.select);	


#객체를 복사 
let car={
  color:'red',
};
let secondCar = car;

car.wheels = 4;

secondCar.drive = 'fast';

console.log(car);
console.log(secondCar);

// 객체를 복사할때 단순히 car에 대한 참조만 저장하기 때문에 car를 수정하면 secondCar도 변경된다. (좀 위험한 방법)

Object.assign() 

let car={
  color:'red',
};
let secondCar = Object.assign({},car);

car.wheels = 4;

secondCar.drive = 'fast';

console.log(car);
console.log(secondCar);

--------------------------------------------------------------

const fruits=['apple', 'banana','orange'];
console.log(fruits[0]);
console.log(fruits.length);


// 배열의 끝에 새 값을 추가
fruits.push('pear');
console.log(fruits);

//배열의 시작에 새 값을 추가
fruits.unshift('melon');
console.log(fruits);

//배열의 끝에서 값 하나를 제거
fruits.pop();
console.log(fruits);

//배열의 시작에 값 하나를 제거
fruits.shift();
console.log(fruits);

"apple"
3
["apple", "banana", "orange", "pear"]
["melon", "apple", "banana", "orange", "pear"]
["melon", "apple", "banana", "orange"]
["apple", "banana", "orange"]

---------------------------------------------------------
매개변수 : 값을 외부에서 내부러 전달할때 (변수선언안한다)

// 1. 함수표현식 function expression
const greeter = function greet(name){
  console.log("hello " +name);
}

greeter("script");
console.log(typeof greeter);


function greet(name){
  console.log("hello " +name);
}
greet("javascript");


// 2. es6 화살표 함수 arrow function
const greeter = (name) => {
  console.log("hello " +name);
}

greeter("script");
//"hello script"

-------------------------------------------------
자바스크립트는 호이스팅(hoisting)을 지원하는데 이는 변수를 어느 위치에서 선언하더라도 사용할 수 있는것을 의미한다.

function hi(){
console.log(a);
var a =1;
}
hi();

// undefined
hoisting(끌어올린다) : 
hi함수가 호출되어 코드가 읽히기 전에 a라는 변수가 있는 정보가 hi실행 컨텍스트 안에 먼저 올라가 있게 된다.(값이 할당되지 않은채로) 이렇게 코드를 읽기 전에 변수 정보가 이미 실행 컨텍스트안에 올라가 버려있으니 변수의 선언 부분이 모두 코드의 최상단으로 끌어올려진것처럼 보이는 것. 이게 호이스팅 현상의 원리이다. 


전역스코프_global scope(범위) : 변수가 어느곳에서나 접근 가능하다
블록스코프_block scope : 변수가 선언된 블룩 내부에서만 접근이 가능하다. 
블록은 함수, 루프, 중괄호{} 로 구분되는 영역을 의미한다.


var str1 = 'var';
let str2 = 'let';


function run(){
  console.log(this.str1);
  console.log(this.str2);
  console.log(str1);
  console.log(str2);

}
run();

"var"
undefined
"var"
"let"


-----------------------------------------
TDZ : 스코프에 진입할 때 변수가 만들어지고 코드 실행이 변수가 실제 있는 위치에 도달할때까지 액세스할수 없는것. let/const 변수가 선언된 시점에서 제어흐름은 TDZ를 떠난 상태가 되며 변수를 사용할수 있게 된다.
let/const 호이스팅을 하지만 변수가 선언되기 전에 사용하면 에러가 발생한다.



var name ="seon";
var name ="hwa";
console.log(name);
//  var는 한번 선언한 변수의 이름으로 다시 재선언 가능

let name ="seon";
let name ="hwa";
console.log(name);
// let은 재선언 불가


let name ="seon";
name ="hwa";
console.log(name);
// let 재할당은 가능

if (true){
 let name ="seon";
console.log(name);
}
console.log(name);
// scope 내에서 선언된 let변수는 외부 접근이 불가능


if (true){
 const name ="seon";
  const name ="hwa";
  name = "seonhwa"
}
// const는 재선언, 재할당 불가능

------------------------------------------------------
var myInt=1;
if(myInt ===1){//true
  var mySecondInt = 2;  //local
  console.log(mySecondInt);	//2
}
console.log(mySecondInt);
var로 선언된 변수는 스코프를 가지지 않기 때문에 블록 외부에서도 그 값에 접근할 수 있다. 
-------------------------------------------------------

let myInt=1;
if(myInt ===1){//true
  let mySecondInt = 2;  //local
  console.log(mySecondInt);	//2
}
console.log(mySecondInt);	// error

블록 스코프 외부에서 지역변수에 접근할수 없다.


---------------------------------------------------------
undefined 는 REPL(Read-eval-print loop) 환경에서 코드를 수행한다.
사용자가 입력을하고 실행하면서 결과를 사용자에게 반환하는 대화형 컴퓨터 프로그래밍 환경 

const myCar ={
  color:'red',
  logColor:function(){
    console.log(this.color);
  },
};

const unboundGetColor =myCar.logColor;
 console.log(unboundGetColor());
const boundGetColor = unboundGetColor.bind(myCar);
console.log(boundGetColor());


/*
undefined   - console.log(this.color);
undefined   - console
"red"       - console.log(this.color);
undefined   - console
*/


------------------------------------------------------------
let ryon = apeach = con = ' ' ;
let ryon = ' ';
let apeach =' ';
let con=' ';
---------------------------------------------------------

함수명도 호이스팅을 한다.
function getName(){
	return 'script';
}


let getName = undefined;
getName = function getName(){
	return 'script';
}
----------------------------------------
// function showMessage(message, from){
//   console.log(`${message} by ${from}`);
// }
//  showMessage('hi!','script');


// 방법 1
// function showMessage(message, from){
//   if(from === undefined){
//     from = 'unknown';
//   }
//   console.log(`${message} by ${from}`);
// }
//  showMessage('hi!','script');

// 방법2
function showMessage(message, from='unknown'){
  console.log(`${message} by ${from}`);
}
 showMessage('hi!');

// console.log(message + " by " + from )





----------------------------------------------------------------

// 크롬에서 console 입력 삭제 
console.clear();
console 영역에서 ctrl+l


엣지에서는 clear();

---------------------------------------------------
es5 -> es6 달라진점(데이터타입)

숫자형 : 큰정수 표현하기 위해 숫자형에 BigInt 표현방식이 새로 생겼다.
심볼형 : 문자열 인자를 받아 고유한 키 값을 생성.


let symbol1 = Symbol('key');
let symbol2 = Symbol('key');

console.log(typeof(symbol1));
console.log(symbol1 === symbol2);

// 동일한 심볼을 만들고 싶다면

const gSymbol1 = Symbol.for('id');
const gSymbol2 = Symbol.for('id');
console.log(gSymbol1 === gSymbol2);


---------------------------------------------------

# 참조형 데이터 타입
객체는 ({}) 안에 '키:값' 형태로 하나 이상의 속성을 표현한 것. 
객체의 속성키는 반드시 문자형이어야 하고 
값은 원시형(숫자, 문자, 불리언, 심볼, null, undefined) 또는 객체가 될수도 있다. 
객체 속성 값에는 다시 객체가 올수 있다.

let obj = {name:'라이언', value:5};
var arr = [3,2,4,5,7];
let myFunc = function(param){
  console.log(param + ' run!');
}

var objliteral = {item:'포도', 
                  getName:function(){
                    return this.item;
                  }
                 };

---------------------------------------------------
console.log('3'+3);
console.log(+'3'+3);// 문자열을 강제로 형변환
console.log('3'-3);// 숫자로 변환
console.log('문자'-2);// 숫자형으로 변환이 불가능
// not a number 
// NaN 인지를 체크를 할수 있는 isNaN() 
--------------------------------------------------------

for(let 초깃값;조건식;증감or증가){
	// 반복 실행문
}
i++ : 1증가
i-- : 1감소

let friends = [
  {name : '라이언', age:5},
  {name : '어피치', age:4},
  {name : '콘', age:2},
  {name : '무지', age:3},
];

for(let i = 0; i <friends.length; i++){
  console.log('이름: '+ friends[i].name + ', 나이: '+friends[i].age );
}
//
"이름: 라이언, 나이: 5"
"이름: 어피치, 나이: 4"
"이름: 콘, 나이: 2"
"이름: 무지, 나이: 3"

# for ~ of (속성이 있는 (배열, 맵, 셋, 문자)객체에만 사용가능)
for(let 개별요소변수명 of 객체명){
	// 반복 실행문
}


일반 객체의 속성에 접근하려면 for ~ in 사용해야 한다.

let friends = [
  {name : '라이언', age:5},
  {name : '어피치', age:4},
  {name : '콘', age:2},
  {name : '무지', age:3},
];

for(let a of friends){
  console.log('이름: '+ a.name + ', 나이: '+a.age );
}
-----------------------------------------------------------

let iterable =[10,20,30];

for(let value of iterable){
	console.log(value);
}
-------------------------------------------------------

# for ~ in문
객체의 전체 속성 키를 나열하는데 사용
기본형 :
for(let 속성 in 객체){
	// 속성 처리 구문
}


let ryon = {name:'라이언', age:5, gender:'male'};

for(let prop in ryon){
  console.log('속성: '+ prop+', 값:'+ryon[prop]);
}

// key == 속성
// value == 값
-----------------------------------------------------
# forEach (array es6부터는 map, set 지원)
기본형 :
배열.forEach(function (요소[, 인덱스]{
	//요소 처리 실행문
});

let friends = [
  {name : '라이언', age:5},
  {name : '어피치', age:4},
  {name : '콘', age:2},
  {name : '무지', age:3},
];

friends.forEach(function(fr,idx){
	console.log('이름 : ' + fr.name + ', 나이 : ' + fr.age);
});
-------------------------------------------------------------------------
const arr = [1, 2, 3];

const objArr = [
  {
    a: 1,
    b: 2,
    c: 3,
  },
  {
    a: 4,
    b: 5,
    c: 6,
  },
];

arr.forEach((value) => {
  console.log(value);
});
objArr.forEach((value, idx) => {
  console.log(value);
});
------------------------------------------
const로 선언된 변수가 불변은 아니다. 
속성중 일부만 재할당 하는것은 문제가 없다.

const person = {
  name:'jia',
  age:25,
};

person.age=35;
console.log(person.age);


객체 자체를 재할당하는것은 오류.
const person = {
  name:'jia',
  age:25,
};

person = {
  name:'sia',
  age:35,
};

console.log(person);

-------------------------------------------------

const person = {
  name:'jia',
  age:25,
};

person.age=15;

console.log(person.age);

Object.freeze(person);//15

person.age=30;

console.log(person.age);

//
15
15

---------------------------------------------------------
# 함수에는 기본값(default)을 줄수 있다
return : 함수내부에서 외부로 값을 내보낸다.
매개변수(parameter): 변수를 통해 값을 외부에서 내부로 전달한다.
인자 : 매개변수를 통해서 전달할 값

function sum(a =0,b=0){
  return a+b;//반환
}
console.log(sum(4,5));
console.log(sum(4));
console.log(sum());

-----------------------------------------------------------

function myFunc(...args){
	// ...args 매개변수의 0개부터~ N개 까지 접근가능
}

let rest2 = (arg1, arg2, ...args)=>{
  console.log([arg1, arg2, args]);
}
rest2(1,2,3,4);
rest2(1,2);
rest2(1);

//
[1, 2, [3, 4]]
[1, 2, []]
[1, undefined, []]

--------------------------------------------------
//화살표 함수
let add =(a,b) => a+b;
console.log(add(1,2));

파라미터 : 0개-빈괄호() 반드시표기 // ()=>{}
	1개-()생략가능 // arg1=>{}
	2개이상 - ()로 파라미터들을 감싸서 표기 // (arg1, arg2)=>{}

return 	: 블록{}으로 코드를 감싼 경우 반환할 값이 있으면 반드시 retrun으로 반환해야 한다.
	: 블록을 생략한 경우에는 return 도 생략 가능

a++ :  a= a+1
b--  : b = b-1

 result = result + a;
 result *= a;


let multiply = (a, b, ...args) =>{  // ...args 3,4
  
  let result = a*b;   // 2
  
  for(let i = 0; i < args.length; i++){
    result *= args[i];// result = result * args[i];
  }                   //    6    =   2    * 3    [0]
                      //    24     =   6    * 4
  return result;//24
}
console.log(multiply(1,2,3,4));

//24

-------------------------------------------------
if(조건식){true}
if(조건식){true}else{false}


function sum(a,b, ...args){
  
  let result = 0;
  // if(조건식){true}else{false}
  if(a != undefined){result =a;}else{return 0;}//result =1
  if(b != undefined){result +=b;}// result= result+b
                                  //   3   =   1 + 2
  args.forEach(function(arg){
      result += arg;  // result = result + arg;  15
  })                  
  return result;
}
console.log(sum(1,2,3,4,5));//15
console.log(sum(1,2));
console.log(sum(1));//1

----------------------------------------------------------
조건식 ? true : false
reduce() : 배열 요소의 누적 계산 결과를 반환

function sum(a,b, ...args){
  
  let result = 0;
  if(a != undefined){result =a;}else{return 0;}//result =1
  if(b != undefined){result +=b;}// result= result+b
                                  
  result += args.length > 0 ? args.reduce((subsum,arg)=>subsum+=arg) : 0; 
  // result = result +12                                                // subsum = subsum + arg
  return result;
}
console.log(sum(1,2,3,4,5));//15
console.log(sum(1,2));//3
console.log(sum(1));//1

----------------------------------------------------

// function orderSet(burger, beverage){
//   console.log("세트: " +burger+", "+beverage)
// }
// orderSet("치즈버거", "콜라");
// orderSet("치즈버거", "커피");


function orderSet(burger){
  return function(beverage){
  console.log("세트: " +burger+", "+beverage)
  }
}
let order = orderSet("치즈버거");
order("콜라");
order("커피");

//
"세트: 치즈버거, 콜라"
"세트: 치즈버거, 커피"


function orderSet(burger){
  return function orderBeverage(beverage){
    return function orderSide(side){
       return function orderKetchup(yn){
          return function orderChicken(count){
            console.log("세트: " +burger+", "+beverage+", "+side+", 케첩("+yn+"), 조각치킨("+count+"개)");
          }
       }
    }
  }
}
let order = orderSet("치즈버거");
console.log(order("콜라")("프렌치후라이")("y")("2"));


--------------------------------------------java2



# 구조 분해 할당 (비구조화 할당)

var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2

----------------------------------
const array=[1,2];
const one = array[0];
const two = array[1];

const array=[1,2];
const [one, two] = array;

-----------------------------------
var person={
  first:"hyeri",
  last:"yoon",
            };

var first= person.first;
var last=person.last;


const person={
  first:"hyeri",
  last:"yoon",
            };

const {first, last} = person;


const person={
  name:"hyeri",
  last:"yoon",
  links:{
    social:{
      youtube:"https://www.youtube.com/",
    },
    facebook:"https://www.facebook.com/",
  },
};

const {youtube:yt} = person.links.social;
console.log(yt);

youtube:yt
변수명을 변경할수 있다.

--------------------------------------------------------
const person =['ju','hee','25'];
// name , surname
const [name, surname] = person;
console.log(name, surname);


const snack=["pizza","ice cream","cake","cookie","Chocolate"];
const [name, surname,...args] = snack;
console.log(food);


let hungry="yes";
let full="no";

[hungry, full] = [full, hungry];
console.log(hungry, full)

---------------------------------------------------
# 전위 연산자, 후위연산자
let A = ++B;	// 변수 B의 데이터를 1증가시킨후 변수 A저장
let A = B++;	// 변수 A에 변수 B의 데이터를 저장한 후 B의 데이터를 1 증가



let a =1;
let b = ++a;

a=a+1;	//2
b=a;	//2
console.log(`a = ${a} , b= ${b}`)


let c = 1;
let d = c++;
console.log(`c = ${c} , d= ${d}`)
// let d=c;
c=c+1
d=1, c=2


  var num1=10;        
   var num2=20;        
   var result;           

   num1--;          	
   console.log(num1);//9

   num1++;       
   console.log(num1);  //10  
	
// 변수 A에 변수 B의 데이터를 저장한 후 B의 데이터를 1 증가
    result=num2++;//result:20, num2:21
   console.log(result); 
	// 변수 B의 데이터를 1증가시킨후 변수 A저장	 
   result=++num2;	// num2:22 , result:22
   console.log(result); 
-------------------------------------------------
const arr = [1,2,3,4];
const arr2x = arr.map(item => item++);
console.log(arr);
console.log(arr2x[0]);


-------------------------------------------
<div class="fruits">
  <p>Apple</p>
  <p>Banana</p>
  <p>Orange</p>
  </div>



const fruits =Array.from(document.querySelectorAll(".fruits p"));
const fruitNames = fruits.map(fruit => fruit.textContent);
console.log(fruitNames);


//Array.from : 배열이 아닌 객체를 받아서 배열로 반환

const fruits =document.querySelectorAll(".fruits p");
const fruitArray = Array.from(fruits, fruit =>{
 return fruit.textContent;
});

console.log(fruitArray);



----------------------------------------
const array = [1,2,3,4,5];
let found=array.find(e => e>3);
console.log(found);

// Array.find() : 조건을 충족하는 첫번째 원소를 반환
console.log(array);
let arrEvery=array.every(e => e>3);
console.log(arrEvery);
------------------------------------
const veggie=["tomato","cucumber","beans"];
const newVeggie = veggie;
veggie.push("peas");
console.log(veggie);
console.log(newVeggie);
-------------------------------------
# 프로토타입
- 자바스크립트는 프로토타입을 기반으로 상속을 구현함
- 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)을 제공
- 모든 객체는 하나의 프로토타입을 갖는다.
- 모든 프로토타입은 생성자 함수와 연결되어 있다.
- 프로퍼티를 사용하는 주체에 따라 다르다.

function person(name) {
    this.name = name;
  //  console.log(this);
}

person.prototype.sayName = function() {
    console.log(`name is ${this.name}`);
};

const me = new person('Jina');
const you = new person('junsu');

me.sayName();
you.sayName();



const obj={}
const obj1 = new();



객체 리터럴   / Object	/ Object.prototype
함수 리터럴  / Function 	/Function.prototype
배열 리터럴 / Array 		/Array.prototype
정규 표현식 / RegExp 	/ RegExp.prototype


	      소유                 사용 주체    사용목적
prototype  / constructor        / 생성자 함수 /생성자 함수가 자신이 
				       생성할 객체의 프로토타입                                                             을 할당하기 위해

__proto__   / 모든 객체          / 모든 객체 / 객체가 자신의 프로토타입				    에 접근 또는 교체 하기 위해 

const myTest = { x: 20 };

const obj = {
    y: 40,

    __proto__: myTest
};
//객체가 자신의 프로토타입에 접근 또는 교체 하기 위해
console.log(`obj.x = ${obj.x}, obj.y = ${obj.y}`);

# class:template이라고 보면됨.
- class는 object(인스턴스)를 만들 수 있는 틀이다
- class 자체에는 data가 들어있지 않음
- 틀(template)을 정의해서 한 번만 선언 한다



